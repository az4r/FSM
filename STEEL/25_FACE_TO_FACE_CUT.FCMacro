# -*- coding: utf-8 -*-
# Face-to-Face: pomiar przez stałą współrzędną narożników (x/y/z)
# Zasada: z każdego face pobieramy 4 punkty narożne (rogi bounding rectangle w płaszczyźnie face).
# Jeśli wszystkie 4 punkty mają tę samą wartość jednej współrzędnej (x lub y lub z) w tolerancji,
# to tę wartość zapamiętujemy. Wynik = abs(value_face1 - value_face2).
# Nie tworzymy żadnych obiektów w dokumencie; wszystko wypisujemy do Report view.
import FreeCAD, FreeCADGui
from PySide2 import QtWidgets, QtCore
import os, math, traceback

# --- USTAWIENIA ---
FILE1 = "face1_info.txt"
FILE2 = "face2_info.txt"
EPS_CONST = 1e-6  # tolerancja porównania współrzędnych

# --- GLOBALNE ---
currentObserver = None
currentDialog = None

# --- POMOCE I/O (oryginalne) ---
def get_model_dir():
    doc = FreeCAD.ActiveDocument
    if doc and getattr(doc, "FileName", None):
        return os.path.dirname(doc.FileName)
    return os.path.expanduser("~")

def safe_str(v):
    try:
        return str(v)
    except Exception:
        return "<unavailable>"

def write_face_info(filepath, obj_name, face):
    lines = []
    lines.append(f"Object: {obj_name}")
    lines.append(f"ShapeType: {safe_str(getattr(face, 'ShapeType', ''))}")
    lines.append(f"Area: {safe_str(getattr(face, 'Area', ''))}")
    lines.append(f"Volume: {safe_str(getattr(face, 'Volume', 0.0))}")
    lines.append(f"Mass: {safe_str(getattr(face, 'Mass', getattr(face, 'Area', 0.0)))}")
    lines.append(f"CenterOfMass: {safe_str(getattr(face, 'CenterOfMass', ''))}")
    lines.append(f"BoundBox: {safe_str(getattr(face, 'BoundBox', ''))}")
    lines.append(f"Placement: {safe_str(getattr(face, 'Placement', None))}")
    try:
        lines.append(f"NormalAt(0,0): {safe_str(face.normalAt(0,0))}")
    except Exception:
        lines.append("NormalAt(0,0): <unavailable>")
    lines.append(f"Edges count: {len(getattr(face, 'Edges', []))}")
    lines.append(f"Vertexes count: {len(getattr(face, 'Vertexes', []))}")
    lines.append(f"Surface: {safe_str(getattr(face, 'Surface', None))}")

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

def read_object_label(filename):
    doc = FreeCAD.ActiveDocument
    if not doc or not getattr(doc, "FileName", None):
        return "brak"
    filepath = os.path.join(os.path.dirname(doc.FileName), filename)
    if os.path.exists(filepath):
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                for line in f:
                    if line.startswith("Object:"):
                        return line.split(":", 1)[1].strip()
        except Exception:
            return "brak"
    return "brak"

# --- OBSERWATOR (oryginalny) ---
class DiagnosticObserver:
    def __init__(self, targetFilename, onDone):
        global currentObserver
        if currentObserver is not None:
            try:
                FreeCADGui.Selection.removeObserver(currentObserver)
            except Exception:
                pass
        currentObserver = self
        self.targetFilename = targetFilename
        self.onDone = onDone
        FreeCADGui.Selection.addObserver(self)

    def addSelection(self, doc_name, obj_name, sub, pnt):
        try:
            sel = FreeCADGui.Selection.getSelectionEx()
            if not sel or not sel[0].SubObjects:
                return
            face = sel[0].SubObjects[0]
            if getattr(face, "ShapeType", "") != "Face":
                return
            model_dir = get_model_dir()
            filepath = os.path.join(model_dir, self.targetFilename)
            write_face_info(filepath, obj_name, face)
            try:
                FreeCAD.Console.PrintMessage(f">>> Dane zapisane do: {filepath}\n")
            except Exception:
                pass
            self._finish()
        except Exception:
            self._finish()

    def _finish(self):
        global currentObserver
        try:
            FreeCADGui.Selection.removeObserver(self)
        except Exception:
            pass
        currentObserver = None
        if callable(self.onDone):
            QtCore.QTimer.singleShot(100, self.onDone)

# --- WEKTORY I POMOCE GEOMETRYCZNE ---
def _vec_add(a,b): return (a[0]+b[0], a[1]+b[1], a[2]+b[2])
def _vec_sub(a,b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])
def _vec_dot(a,b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
def _vec_cross(a,b): return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])
def _vec_scale(a,s): return (a[0]*s, a[1]*s, a[2]*s)
def _vec_len(a): return math.sqrt(_vec_dot(a,a))
def _normalize(a):
    L = _vec_len(a)
    if L == 0: return (0.0,0.0,0.0)
    return (a[0]/L, a[1]/L, a[2]/L)

# --- funkcja: cztery rogi prostokąta ograniczającego face (w globalnych współrzędnych) ---
def build_plane_basis(normal):
    gx = (1.0, 0.0, 0.0)
    gy = (0.0, 1.0, 0.0)
    dot_gx_n = _vec_dot(gx, normal)
    u = _vec_sub(gx, _vec_scale(normal, dot_gx_n))
    if _vec_len(u) < 1e-9:
        dot_gy_n = _vec_dot(gy, normal)
        u = _vec_sub(gy, _vec_scale(normal, dot_gy_n))
        if _vec_len(u) < 1e-9:
            if abs(normal[0]) < 0.9:
                u = (0.0, -normal[2], normal[1])
            else:
                u = (-normal[1], normal[0], 0.0)
    u = _normalize(u)
    v = _normalize(_vec_cross(normal, u))
    return u, v

def project_point_to_plane_2d(p, origin, u, v):
    rel = _vec_sub(p, origin)
    return (_vec_dot(rel, u), _vec_dot(rel, v))

def point2d_to_3d(pt2, origin, u, v):
    return _vec_add(origin, _vec_add(_vec_scale(u, pt2[0]), _vec_scale(v, pt2[1])))

def face_four_corners(face):
    """
    Zwraca listę 4 punktów (x,y,z) będących rogami bounding rectangle face w jego własnej płaszczyźnie.
    Jeśli face ma dokładnie 4 wierzchołki, zwraca je w kolejności (unikalne).
    """
    verts = []
    try:
        for v in face.Vertexes:
            p = v.Point
            tup = (float(p.x), float(p.y), float(p.z))
            if tup not in verts:
                verts.append(tup)
    except Exception:
        return []

    if not verts:
        return []

    # jeśli face ma dokładnie 4 unikalne wierzchołki, zwróć je (stabilna kolejność nie gwarantowana, ale wartości są poprawne)
    if len(verts) == 4:
        return verts[:]

    # origin: CenterOfMass jeśli dostępne, inaczej średnia wierzchołków
    try:
        cm = getattr(face, "CenterOfMass", None)
        if cm is not None and hasattr(cm, "x"):
            origin = (float(cm.x), float(cm.y), float(cm.z))
        else:
            sx = sy = sz = 0.0
            for p in verts:
                sx += p[0]; sy += p[1]; sz += p[2]
            n = len(verts)
            origin = (sx/n, sy/n, sz/n)
    except Exception:
        origin = verts[0]

    # normala: preferuj face.normalAt(0,0)
    try:
        nvec = face.normalAt(0,0)
        normal = (float(nvec.x), float(nvec.y), float(nvec.z)) if hasattr(nvec,'x') else tuple(nvec)
    except Exception:
        # fallback: normala z pierwszych trzech niekolinearnych wierzchołków
        normal = (0.0,0.0,1.0)
        if len(verts) >= 3:
            a = _vec_sub(verts[1], verts[0])
            b = _vec_sub(verts[2], verts[0])
            c = _vec_cross(a,b)
            if _vec_len(c) > 1e-12:
                normal = _normalize(c)

    normal = _normalize(normal)
    u, v = build_plane_basis(normal)

    pts2 = [project_point_to_plane_2d(p, origin, u, v) for p in verts]
    us = [p[0] for p in pts2]; vs = [p[1] for p in pts2]
    umin, umax = min(us), max(us)
    vmin, vmax = min(vs), max(vs)
    corners2 = [(umin, vmin), (umax, vmin), (umax, vmax), (umin, vmax)]
    corners3 = [point2d_to_3d(c, origin, u, v) for c in corners2]
    # zwróć jako listę krotek (x,y,z)
    return [(float(p[0]), float(p[1]), float(p[2])) for p in corners3]

# --- pomoc: sprawdź czy w 4 punktach jedna współrzędna jest stała (x/y/z) w tolerancji EPS_CONST ---
def find_constant_coordinate(points, eps=EPS_CONST):
    """
    points: lista 4 punktów (x,y,z)
    zwraca: (axis, value) gdzie axis in ('x','y','z') i value float,
            lub (None, None) jeśli brak stałej współrzędnej
    """
    if not points or len(points) < 1:
        return None, None
    # sprawdź x, y, z
    for idx, axis in enumerate(('x','y','z')):
        vals = [p[idx] for p in points]
        mn = min(vals); mx = max(vals)
        if abs(mx - mn) <= eps:
            return axis, sum(vals)/len(vals)
    return None, None

# --- heurystyka dopasowania twarzy (jak wcześniej) ---
def find_best_face_index(obj, signature_file):
    sig = {}
    doc = FreeCAD.ActiveDocument
    path = os.path.join(os.path.dirname(doc.FileName), signature_file) if getattr(doc, "FileName", None) else None
    if path and os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    if line.startswith("Area:"):
                        try: sig['Area'] = float(line.split(":",1)[1].strip())
                        except: pass
                    if line.startswith("CenterOfMass:"):
                        txt = line.split(":",1)[1].strip()
                        nums = [s for s in txt.replace("(", " ").replace(")", " ").replace(",", " ").split() if s.replace('.','',1).lstrip('-').isdigit()]
                        if len(nums)>=3: sig['CenterOfMass'] = (float(nums[0]), float(nums[1]), float(nums[2]))
                    if line.startswith("NormalAt(0,0):"):
                        txt = line.split(":",1)[1].strip()
                        nums = [s for s in txt.replace("(", " ").replace(")", " ").replace(",", " ").split() if s.replace('.','',1).lstrip('-').isdigit()]
                        if len(nums)>=3: sig['Normal'] = (float(nums[0]), float(nums[1]), float(nums[2]))
        except Exception:
            pass
    best_idx = None; best_score = 1e9
    try:
        faces = obj.Shape.Faces
    except Exception:
        return None
    for i,f in enumerate(faces):
        score = 0.0
        try:
            if 'Area' in sig and sig['Area']>0:
                score += abs(f.Area - sig['Area'])/(sig['Area']+1e-12)
            else:
                score += 0.5
        except Exception:
            score += 1.0
        try:
            if 'CenterOfMass' in sig:
                d = _vec_len(_vec_sub(f.CenterOfMass, sig['CenterOfMass']))
                score += d/1e-3
            else:
                score += 0.5
        except Exception:
            score += 1.0
        try:
            n = f.normalAt(0,0)
            n_t = (n.x, n.y, n.z) if hasattr(n, 'x') else tuple(n)
            if 'Normal' in sig:
                nn = n_t; sn = sig['Normal']
                ln = _vec_len(nn); lsn = _vec_len(sn)
                if ln>0 and lsn>0:
                    dotp = abs(_vec_dot(nn, sn)/(ln*lsn))
                    score += (1.0 - dotp)
                else:
                    score += 0.5
            else:
                score += 0.5
        except Exception:
            score += 1.0
        if score < best_score:
            best_score = score; best_idx = i
    return best_idx

# --- GŁÓWNA METODA on_ok: użycie narożników i różnicy stałej współrzędnej ---
def _dialog_on_ok(self):
    try:
        doc = FreeCAD.ActiveDocument
        if not doc:
            FreeCAD.Console.PrintError(">>> Brak aktywnego dokumentu.\n")
            self.accept(); return

        def read_objname(fn):
            path = os.path.join(os.path.dirname(doc.FileName), fn) if getattr(doc, "FileName", None) else None
            if not path or not os.path.exists(path): return None
            try:
                with open(path, "r", encoding="utf-8") as f:
                    for line in f:
                        if line.startswith("Object:"):
                            return line.split(":",1)[1].strip()
            except Exception:
                return None
            return None

        obj1name = read_objname(FILE1)
        obj2name = read_objname(FILE2)
        if not obj1name or not obj2name:
            FreeCAD.Console.PrintMessage(">>> Brak zapisanych wyborów (face1/face2). Upewnij się, że wybrałeś obie twarze.\n")
            self.accept(); return

        o1 = doc.getObject(obj1name)
        o2 = doc.getObject(obj2name)
        if o1 is None or o2 is None:
            FreeCAD.Console.PrintError(">>> Nie znaleziono obiektu(y) w dokumencie: %s, %s\n" % (str(obj1name), str(obj2name)))
            self.accept(); return

        idx1 = find_best_face_index(o1, FILE1)
        idx2 = find_best_face_index(o2, FILE2)
        if idx1 is None or idx2 is None:
            FreeCAD.Console.PrintMessage(">>> Nie udało się zidentyfikować twarzy w obiektach.\n")
            self.accept(); return

        try:
            f1 = o1.Shape.Faces[idx1]
            f2 = o2.Shape.Faces[idx2]
        except Exception as e:
            FreeCAD.Console.PrintError(">>> Błąd pobrania Face: %s\n" % str(e))
            self.accept(); return

        # pobierz 4 narożne punkty dla obu face
        corners1 = face_four_corners(f1)
        corners2 = face_four_corners(f2)
        FreeCAD.Console.PrintMessage(">>> Face1 corners: %s\n" % (", ".join(["(%.6f, %.6f, %.6f)"%p for p in corners1]) if corners1 else "<none>"))
        FreeCAD.Console.PrintMessage(">>> Face2 corners: %s\n" % (", ".join(["(%.6f, %.6f, %.6f)"%p for p in corners2]) if corners2 else "<none>"))

        axis1, val1 = find_constant_coordinate(corners1, eps=EPS_CONST)
        axis2, val2 = find_constant_coordinate(corners2, eps=EPS_CONST)

        if axis1 is not None and axis2 is not None:
            FreeCAD.Console.PrintMessage(">>> Face1 constant axis: %s = %.6f\n" % (axis1, val1))
            FreeCAD.Console.PrintMessage(">>> Face2 constant axis: %s = %.6f\n" % (axis2, val2))
            if axis1 == axis2:
                dist = abs(val1 - val2)
                FreeCAD.Console.PrintMessage(">>> Wynik (różnica stałych współrzędnych %s) = %.6f\n" % (axis1, dist))
            else:
                FreeCAD.Console.PrintMessage(">>> Stałe współrzędne różne (face1: %s, face2: %s). Nie można bezpośrednio odjąć.\n" % (str(axis1), str(axis2)))
                # diagnostyka fallback
                try:
                    dinfo = f1.distToShape(f2)
                    dmin = dinfo[0] if dinfo and len(dinfo)>0 else None
                    if dmin is not None:
                        FreeCAD.Console.PrintMessage(">>> (Porównanie) distToShape = %.12f\n" % dmin)
                except Exception:
                    pass
        else:
            FreeCAD.Console.PrintMessage(">>> Nie znaleziono stałej współrzędnej (x/y/z) we wszystkich 4 narożnikach jednego z face'ów.\n")
            # diagnostyka: centroidy, normaly, distToShape
            try:
                cm1 = getattr(f1, "CenterOfMass", None)
                cm2 = getattr(f2, "CenterOfMass", None)
                if cm1 and hasattr(cm1,'x') and cm2 and hasattr(cm2,'x'):
                    FreeCAD.Console.PrintMessage(">>> Centroid1: (%.6f, %.6f, %.6f)\n" % (cm1.x, cm1.y, cm1.z))
                    FreeCAD.Console.PrintMessage(">>> Centroid2: (%.6f, %.6f, %.6f)\n" % (cm2.x, cm2.y, cm2.z))
                try:
                    dinfo = f1.distToShape(f2)
                    dmin = dinfo[0] if dinfo and len(dinfo)>0 else None
                    if dmin is not None:
                        FreeCAD.Console.PrintMessage(">>> (Porównanie) distToShape = %.12f\n" % dmin)
                except Exception:
                    pass
            except Exception:
                pass

    except Exception:
        FreeCAD.Console.PrintError(">>> Błąd w on_ok:\n%s\n" % traceback.format_exc())
    finally:
        self.accept()

# --- UI (oryginalne) ---
class MyDialog(QtWidgets.QDialog):
    def __init__(self):
        super(MyDialog, self).__init__()
        self.setWindowTitle("Makro diagnostyczne (Face1/Face2) - stała współrzędna z narożników")

        layout = QtWidgets.QVBoxLayout()

        self.btn1 = QtWidgets.QPushButton("Wybierz Face 1")
        self.label1 = QtWidgets.QLabel(read_object_label(FILE1))
        h1 = QtWidgets.QHBoxLayout()
        h1.addWidget(self.btn1)
        h1.addWidget(self.label1)
        layout.addLayout(h1)

        self.btn2 = QtWidgets.QPushButton("Wybierz Face 2")
        self.label2 = QtWidgets.QLabel(read_object_label(FILE2))
        h2 = QtWidgets.QHBoxLayout()
        h2.addWidget(self.btn2)
        h2.addWidget(self.label2)
        layout.addLayout(h2)

        self.okbtn = QtWidgets.QPushButton("OK")
        layout.addWidget(self.okbtn)

        self.setLayout(layout)

        self.btn1.clicked.connect(lambda: self.startDiagnostic(FILE1, button_label="Wybierz Face 1"))
        self.btn2.clicked.connect(lambda: self.startDiagnostic(FILE2, button_label="Wybierz Face 2"))
        self.okbtn.clicked.connect(self.on_ok)

    def startDiagnostic(self, filename, button_label=None):
        if button_label:
            try:
                FreeCAD.Console.PrintMessage(f">>> {button_label}\n")
            except Exception:
                pass
        self.hide()
        DiagnosticObserver(filename, onDone=self._returnAndRefresh)

    def _returnAndRefresh(self):
        self.label1.setText(read_object_label(FILE1))
        self.label2.setText(read_object_label(FILE2))
        self.show()

# Podłączamy metodę on_ok
MyDialog.on_ok = _dialog_on_ok

# --- START ---
def run():
    global currentDialog
    if currentDialog is None:
        currentDialog = MyDialog()
    currentDialog.show()

if __name__ == "__main__":
    run()

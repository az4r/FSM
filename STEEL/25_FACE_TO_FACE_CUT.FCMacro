# -*- coding: utf-8 -*-
# Face-to-Face: pomiar przez stałą współrzędną narożników (x/y/z)
# Zmiana: zapis SubElement (np. Face7) przy wyborze i bezpośrednie użycie tego identyfikatora
#       przy odczycie, z heurystycznym fallbackem jeśli subelement nie jest dostępny.
# Nie tworzymy żadnych obiektów w dokumencie; wszystko wypisujemy do Report view.
import FreeCAD, FreeCADGui
from PySide2 import QtWidgets, QtCore
import os, math, traceback

# --- USTAWIENIA ---
FILE1 = "face1_info.txt"
FILE2 = "face2_info.txt"
EPS_CONST = 1e-6  # tolerancja porównania współrzędnych

# --- GLOBALNE ---
currentObserver = None
currentDialog = None

# --- POMOCE I/O ---
def get_model_dir():
    doc = FreeCAD.ActiveDocument
    if doc and getattr(doc, "FileName", None):
        return os.path.dirname(doc.FileName)
    return os.path.expanduser("~")

def safe_str(v):
    try:
        return str(v)
    except Exception:
        return "<unavailable>"

def write_face_info(filepath, obj_name, face, subelement_name=None):
    """
    Zapisuje informacje o wyborze face do pliku. Dodatkowo zapisuje SubElement (np. Face7),
    jeśli jest dostępny — to pozwoli na deterministyczne odczytanie tej samej twarzy później.
    """
    lines = []
    lines.append(f"Object: {obj_name}")
    if subelement_name:
        lines.append(f"SubElement: {subelement_name}")
    lines.append(f"ShapeType: {safe_str(getattr(face, 'ShapeType', ''))}")
    lines.append(f"Area: {safe_str(getattr(face, 'Area', ''))}")
    lines.append(f"Volume: {safe_str(getattr(face, 'Volume', 0.0))}")
    lines.append(f"Mass: {safe_str(getattr(face, 'Mass', getattr(face, 'Area', 0.0)))}")
    lines.append(f"CenterOfMass: {safe_str(getattr(face, 'CenterOfMass', ''))}")
    lines.append(f"BoundBox: {safe_str(getattr(face, 'BoundBox', ''))}")
    lines.append(f"Placement: {safe_str(getattr(face, 'Placement', None))}")
    try:
        lines.append(f"NormalAt(0,0): {safe_str(face.normalAt(0,0))}")
    except Exception:
        lines.append("NormalAt(0,0): <unavailable>")
    lines.append(f"Edges count: {len(getattr(face, 'Edges', []))}")
    lines.append(f"Vertexes count: {len(getattr(face, 'Vertexes', []))}")
    lines.append(f"Surface: {safe_str(getattr(face, 'Surface', None))}")

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

def read_obj_and_subelement(fn):
    """
    Odczytuje z pliku Object i SubElement (jeśli zapisane).
    Zwraca (object_name_or_None, subelement_or_None).
    """
    doc = FreeCAD.ActiveDocument
    if not doc or not getattr(doc, "FileName", None):
        return None, None
    path = os.path.join(os.path.dirname(doc.FileName), fn)
    if not os.path.exists(path):
        return None, None
    objname = None; subelem = None
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                if line.startswith("Object:"):
                    objname = line.split(":",1)[1].strip()
                if line.startswith("SubElement:"):
                    subelem = line.split(":",1)[1].strip()
    except Exception:
        return objname, subelem
    return objname, subelem

def read_object_label(filename):
    # zachowujemy kompatybilność z UI (tylko nazwa obiektu)
    name, _ = read_obj_and_subelement(filename)
    return name if name else "brak"

# --- OBSERWATOR (zapisuje SubElement) ---
class DiagnosticObserver:
    def __init__(self, targetFilename, onDone):
        global currentObserver
        if currentObserver is not None:
            try:
                FreeCADGui.Selection.removeObserver(currentObserver)
            except Exception:
                pass
        currentObserver = self
        self.targetFilename = targetFilename
        self.onDone = onDone
        FreeCADGui.Selection.addObserver(self)

    def addSelection(self, doc_name, obj_name, sub, pnt):
        try:
            sel = FreeCADGui.Selection.getSelectionEx()
            if not sel or not sel[0].SubObjects:
                return
            sel0 = sel[0]
            face = sel0.SubObjects[0]
            if getattr(face, "ShapeType", "") != "Face":
                return
            # spróbuj pobrać SubElementName (np. "Face7")
            subelem = None
            try:
                s = getattr(sel0, "SubElementNames", None)
                if s and len(s) > 0:
                    subelem = s[0]
            except Exception:
                subelem = None

            model_dir = get_model_dir()
            filepath = os.path.join(model_dir, self.targetFilename)
            write_face_info(filepath, obj_name, face, subelement_name=subelem)

            try:
                FreeCAD.Console.PrintMessage(f">>> Dane zapisane do: {filepath}\n")
            except Exception:
                pass

            self._finish()
        except Exception:
            self._finish()

    def _finish(self):
        global currentObserver
        try:
            FreeCADGui.Selection.removeObserver(self)
        except Exception:
            pass
        currentObserver = None
        if callable(self.onDone):
            QtCore.QTimer.singleShot(100, self.onDone)

# --- WEKTORY I POMOCE GEOMETRYCZNE ---
def _vec_add(a,b): return (a[0]+b[0], a[1]+b[1], a[2]+b[2])
def _vec_sub(a,b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])
def _vec_dot(a,b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
def _vec_cross(a,b): return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])
def _vec_scale(a,s): return (a[0]*s, a[1]*s, a[2]*s)
def _vec_len(a): return math.sqrt(_vec_dot(a,a))
def _normalize(a):
    L = _vec_len(a)
    if L == 0: return (0.0,0.0,0.0)
    return (a[0]/L, a[1]/L, a[2]/L)

# --- funkcje pomocnicze do narożników (stabilne) ---
def build_plane_basis(normal):
    gx = (1.0, 0.0, 0.0)
    gy = (0.0, 1.0, 0.0)
    dot_gx_n = _vec_dot(gx, normal)
    u = _vec_sub(gx, _vec_scale(normal, dot_gx_n))
    if _vec_len(u) < 1e-9:
        dot_gy_n = _vec_dot(gy, normal)
        u = _vec_sub(gy, _vec_scale(normal, dot_gy_n))
        if _vec_len(u) < 1e-9:
            if abs(normal[0]) < 0.9:
                u = (0.0, -normal[2], normal[1])
            else:
                u = (-normal[1], normal[0], 0.0)
    u = _normalize(u)
    v = _normalize(_vec_cross(normal, u))
    return u, v

def project_point_to_plane_2d(p, origin, u, v):
    rel = _vec_sub(p, origin)
    return (_vec_dot(rel, u), _vec_dot(rel, v))

def point2d_to_3d(pt2, origin, u, v):
    return _vec_add(origin, _vec_add(_vec_scale(u, pt2[0]), _vec_scale(v, pt2[1])))

def face_four_corners(face):
    """
    Stabilna wersja:
    - jeśli face ma dokładnie 4 unikalne wierzchołki, zwraca je (posortowane) w globalnych współrzędnych;
    - w przeciwnym razie wykonuje fallback: projekcja na lokalną bazę płaszczyzny i bounding rectangle.
    """
    verts = []
    try:
        for v in face.Vertexes:
            p = v.Point
            tup = (float(p.x), float(p.y), float(p.z))
            if tup not in verts:
                verts.append(tup)
    except Exception:
        return []

    if not verts:
        return []

    # Jeśli mamy dokładnie 4 unikalne wierzchołki — użyj ich bez projekcji
    if len(verts) == 4:
        verts_sorted = sorted(verts, key=lambda p: (round(p[0],6), round(p[1],6), round(p[2],6)))
        return verts_sorted

    # fallback: projekcja (jak wcześniej)
    try:
        cm = getattr(face, "CenterOfMass", None)
        if cm is not None and hasattr(cm, "x"):
            origin = (float(cm.x), float(cm.y), float(cm.z))
        else:
            sx = sy = sz = 0.0
            for p in verts:
                sx += p[0]; sy += p[1]; sz += p[2]
            n = len(verts)
            origin = (sx/n, sy/n, sz/n)
    except Exception:
        origin = verts[0]

    try:
        nvec = face.normalAt(0,0)
        normal = (float(nvec.x), float(nvec.y), float(nvec.z)) if hasattr(nvec,'x') else tuple(nvec)
    except Exception:
        normal = (0.0,0.0,1.0)
        if len(verts) >= 3:
            a = _vec_sub(verts[1], verts[0])
            b = _vec_sub(verts[2], verts[0])
            c = _vec_cross(a,b)
            if _vec_len(c) > 1e-12:
                normal = _normalize(c)

    normal = _normalize(normal)
    u, v = build_plane_basis(normal)

    pts2 = [project_point_to_plane_2d(p, origin, u, v) for p in verts]
    us = [p[0] for p in pts2]; vs = [p[1] for p in pts2]
    umin, umax = min(us), max(us)
    vmin, vmax = min(vs), max(vs)
    corners2 = [(umin, vmin), (umax, vmin), (umax, vmax), (umin, vmax)]
    corners3 = [point2d_to_3d(c, origin, u, v) for c in corners2]
    return [(float(p[0]), float(p[1]), float(p[2])) for p in corners3]

# --- pomoc: sprawdź czy w 4 punktach jedna współrzędna jest stała ---
def find_constant_coordinate(points, eps=EPS_CONST):
    if not points or len(points) < 1:
        return None, None
    for idx, axis in enumerate(('x','y','z')):
        vals = [p[idx] for p in points]
        mn = min(vals); mx = max(vals)
        if abs(mx - mn) <= eps:
            return axis, sum(vals)/len(vals)
    return None, None

# --- pomocnicze dla poprawki: porównanie punktów i centroid ---
def points_almost_equal(a, b, eps=1e-6):
    if not a or not b or len(a) != len(b): return False
    def keyf(p): return (round(p[0],6), round(p[1],6), round(p[2],6))
    sa = sorted(a, key=keyf)
    sb = sorted(b, key=keyf)
    for p,q in zip(sa,sb):
        if abs(p[0]-q[0])>eps or abs(p[1]-q[1])>eps or abs(p[2]-q[2])>eps:
            return False
    return True

def face_centroid_tuple(face, fallback_points=None):
    try:
        cm = getattr(face, "CenterOfMass", None)
        if cm and hasattr(cm, "x"):
            return (float(cm.x), float(cm.y), float(cm.z))
    except Exception:
        pass
    if fallback_points:
        sx = sy = sz = 0.0
        for p in fallback_points:
            sx += p[0]; sy += p[1]; sz += p[2]
        n = len(fallback_points)
        return (sx/n, sy/n, sz/n)
    return (0.0,0.0,0.0)

# --- heurystyka dopasowania twarzy (fallback) ---
def find_best_face_index(obj, signature_file):
    sig = {}
    doc = FreeCAD.ActiveDocument
    path = os.path.join(os.path.dirname(doc.FileName), signature_file) if getattr(doc, "FileName", None) else None
    if path and os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    if line.startswith("Area:"):
                        try: sig['Area'] = float(line.split(":",1)[1].strip())
                        except: pass
                    if line.startswith("CenterOfMass:"):
                        txt = line.split(":",1)[1].strip()
                        nums = [s for s in txt.replace("(", " ").replace(")", " ").replace(",", " ").split() if s.replace('.','',1).lstrip('-').isdigit()]
                        if len(nums)>=3: sig['CenterOfMass'] = (float(nums[0]), float(nums[1]), float(nums[2]))
                    if line.startswith("NormalAt(0,0):"):
                        txt = line.split(":",1)[1].strip()
                        nums = [s for s in txt.replace("(", " ").replace(")", " ").replace(",", " ").split() if s.replace('.','',1).lstrip('-').isdigit()]
                        if len(nums)>=3: sig['Normal'] = (float(nums[0]), float(nums[1]), float(nums[2]))
        except Exception:
            pass
    best_idx = None; best_score = 1e9
    try:
        faces = obj.Shape.Faces
    except Exception:
        return None
    for i,f in enumerate(faces):
        score = 0.0
        try:
            if 'Area' in sig and sig['Area']>0:
                score += abs(f.Area - sig['Area'])/(sig['Area']+1e-12)
            else:
                score += 0.5
        except Exception:
            score += 1.0
        try:
            if 'CenterOfMass' in sig:
                d = _vec_len(_vec_sub(f.CenterOfMass, sig['CenterOfMass']))
                score += d/1e-3
            else:
                score += 0.5
        except Exception:
            score += 1.0
        try:
            n = f.normalAt(0,0)
            n_t = (n.x, n.y, n.z) if hasattr(n, 'x') else tuple(n)
            if 'Normal' in sig:
                nn = n_t; sn = sig['Normal']
                ln = _vec_len(nn); lsn = _vec_len(sn)
                if ln>0 and lsn>0:
                    dotp = abs(_vec_dot(nn, sn)/(ln*lsn))
                    score += (1.0 - dotp)
                else:
                    score += 0.5
            else:
                score += 0.5
        except Exception:
            score += 1.0
        if score < best_score:
            best_score = score; best_idx = i
    return best_idx

# --- pomoc: pobierz face bezpośrednio z subelementu lub fallback ---
def face_from_subelement(obj, subelem, fallback_index_func):
    """
    Jeśli subelem ma postać 'FaceN', zwraca obj.Shape.Faces[N-1] (jeśli istnieje).
    W przeciwnym razie używa fallback_index_func(obj) by znaleźć indeks heurystycznie.
    """
    if obj is None:
        return None
    if subelem and isinstance(subelem, str) and subelem.lower().startswith("face"):
        try:
            idx = int(subelem[4:]) - 1
            if idx >= 0 and idx < len(obj.Shape.Faces):
                return obj.Shape.Faces[idx]
        except Exception:
            pass
    # fallback heurystyczny
    idx = fallback_index_func(obj)
    try:
        return obj.Shape.Faces[idx] if idx is not None else None
    except Exception:
        return None

# --- GŁÓWNA METODA on_ok: użycie subelement + narożników i różnicy stałej współrzędnej ---
def _dialog_on_ok(self):
    try:
        doc = FreeCAD.ActiveDocument
        if not doc:
            FreeCAD.Console.PrintError(">>> Brak aktywnego dokumentu.\n")
            self.accept(); return

        obj1name, sub1 = read_obj_and_subelement(FILE1)
        obj2name, sub2 = read_obj_and_subelement(FILE2)
        if not obj1name or not obj2name:
            FreeCAD.Console.PrintMessage(">>> Brak zapisanych wyborów (face1/face2). Upewnij się, że wybrałeś obie twarze.\n")
            self.accept(); return

        o1 = doc.getObject(obj1name)
        o2 = doc.getObject(obj2name)
        if o1 is None or o2 is None:
            FreeCAD.Console.PrintError(">>> Nie znaleziono obiektu(y) w dokumencie: %s, %s\n" % (str(obj1name), str(obj2name)))
            self.accept(); return

        # pobierz facey: najpierw spróbuj użyć zapisanego SubElement, potem heurystyka
        f1 = face_from_subelement(o1, sub1, lambda obj: find_best_face_index(obj, FILE1))
        f2 = face_from_subelement(o2, sub2, lambda obj: find_best_face_index(obj, FILE2))
        if f1 is None or f2 is None:
            FreeCAD.Console.PrintMessage(">>> Nie udało się zidentyfikować twarzy w obiektach.\n")
            self.accept(); return

        # pobierz 4 narożne punkty dla obu face
        corners1 = face_four_corners(f1)
        corners2 = face_four_corners(f2)
        FreeCAD.Console.PrintMessage(">>> Face1 corners: %s\n" % (", ".join(["(%.6f, %.6f, %.6f)"%p for p in corners1]) if corners1 else "<none>"))
        FreeCAD.Console.PrintMessage(">>> Face2 corners: %s\n" % (", ".join(["(%.6f, %.6f, %.6f)"%p for p in corners2]) if corners2 else "<none>"))

        axis1, val1 = find_constant_coordinate(corners1, eps=EPS_CONST)
        axis2, val2 = find_constant_coordinate(corners2, eps=EPS_CONST)

        # pobierz centroidy (globalne) do diagnostyki i poprawki
        cent1 = face_centroid_tuple(f1, fallback_points=corners1)
        cent2 = face_centroid_tuple(f2, fallback_points=corners2)

        # jeśli narożniki praktycznie identyczne, ale centroidy różne -> użyj różnicy centroidów
        if points_almost_equal(corners1, corners2, eps=1e-6):
            chosen_axis = axis1 if axis1 is not None else (axis2 if axis2 is not None else None)
            if chosen_axis is None:
                try:
                    nvec = f1.normalAt(0,0)
                    n_abs = (abs(nvec.x), abs(nvec.y), abs(nvec.z))
                    max_idx = 0 if n_abs[0] >= n_abs[1] and n_abs[0] >= n_abs[2] else (1 if n_abs[1] >= n_abs[2] else 2)
                    chosen_axis = ('x','y','z')[max_idx]
                except Exception:
                    chosen_axis = 'z'
            idx = {'x':0,'y':1,'z':2}[chosen_axis]
            dist_centroids = abs(cent1[idx] - cent2[idx])
            FreeCAD.Console.PrintMessage(">>> Uwaga: narożniki praktycznie identyczne — używam różnicy centroidów w osi %s = %.6f\n" % (chosen_axis, dist_centroids))
            FreeCAD.Console.PrintMessage(">>> Face1 centroid: (%.6f, %.6f, %.6f)\n" % tuple(cent1))
            FreeCAD.Console.PrintMessage(">>> Face2 centroid: (%.6f, %.6f, %.6f)\n" % tuple(cent2))
            FreeCAD.Console.PrintMessage(">>> Wynik (z centroidów) = %.6f\n" % dist_centroids)
        else:
            # normalna logika: jeśli obie mają stałą tę samą oś -> odejmij wartości
            if axis1 is not None and axis2 is not None:
                FreeCAD.Console.PrintMessage(">>> Face1 constant axis: %s = %.6f\n" % (axis1, val1))
                FreeCAD.Console.PrintMessage(">>> Face2 constant axis: %s = %.6f\n" % (axis2, val2))
                if axis1 == axis2:
                    dist = abs(val1 - val2)
                    FreeCAD.Console.PrintMessage(">>> Wynik (różnica stałych współrzędnych %s) = %.6f\n" % (axis1, dist))
                else:
                    FreeCAD.Console.PrintMessage(">>> Stałe współrzędne różne (face1: %s, face2: %s). Nie można bezpośrednio odjąć.\n" % (str(axis1), str(axis2)))
                    try:
                        dinfo = f1.distToShape(f2)
                        dmin = dinfo[0] if dinfo and len(dinfo)>0 else None
                        if dmin is not None:
                            FreeCAD.Console.PrintMessage(">>> (Porównanie) distToShape = %.12f\n" % dmin)
                    except Exception:
                        pass
            else:
                FreeCAD.Console.PrintMessage(">>> Nie znaleziono stałej współrzędnej (x/y/z) we wszystkich 4 narożnikach jednego z face'ów.\n")
                try:
                    if cent1 and cent2:
                        FreeCAD.Console.PrintMessage(">>> Centroid1: (%.6f, %.6f, %.6f)\n" % tuple(cent1))
                        FreeCAD.Console.PrintMessage(">>> Centroid2: (%.6f, %.6f, %.6f)\n" % tuple(cent2))
                    try:
                        dinfo = f1.distToShape(f2)
                        dmin = dinfo[0] if dinfo and len(dinfo)>0 else None
                        if dmin is not None:
                            FreeCAD.Console.PrintMessage(">>> (Porównanie) distToShape = %.12f\n" % dmin)
                    except Exception:
                        pass
                except Exception:
                    pass

    except Exception:
        FreeCAD.Console.PrintError(">>> Błąd w on_ok:\n%s\n" % traceback.format_exc())
    finally:
        self.accept()

# --- UI ---
class MyDialog(QtWidgets.QDialog):
    def __init__(self):
        super(MyDialog, self).__init__()
        self.setWindowTitle("Makro diagnostyczne (Face1/Face2) - SubElement support")

        layout = QtWidgets.QVBoxLayout()

        self.btn1 = QtWidgets.QPushButton("Wybierz Face 1")
        self.label1 = QtWidgets.QLabel(read_object_label(FILE1))
        h1 = QtWidgets.QHBoxLayout()
        h1.addWidget(self.btn1)
        h1.addWidget(self.label1)
        layout.addLayout(h1)

        self.btn2 = QtWidgets.QPushButton("Wybierz Face 2")
        self.label2 = QtWidgets.QLabel(read_object_label(FILE2))
        h2 = QtWidgets.QHBoxLayout()
        h2.addWidget(self.btn2)
        h2.addWidget(self.label2)
        layout.addLayout(h2)

        self.okbtn = QtWidgets.QPushButton("OK")
        layout.addWidget(self.okbtn)

        self.setLayout(layout)

        self.btn1.clicked.connect(lambda: self.startDiagnostic(FILE1, button_label="Wybierz Face 1"))
        self.btn2.clicked.connect(lambda: self.startDiagnostic(FILE2, button_label="Wybierz Face 2"))
        self.okbtn.clicked.connect(self.on_ok)

    def startDiagnostic(self, filename, button_label=None):
        if button_label:
            try:
                FreeCAD.Console.PrintMessage(f">>> {button_label}\n")
            except Exception:
                pass
        self.hide()
        DiagnosticObserver(filename, onDone=self._returnAndRefresh)

    def _returnAndRefresh(self):
        self.label1.setText(read_object_label(FILE1))
        self.label2.setText(read_object_label(FILE2))
        self.show()

# Podłączamy metodę on_ok
MyDialog.on_ok = _dialog_on_ok

# --- START ---
def run():
    global currentDialog
    if currentDialog is None:
        currentDialog = MyDialog()
    currentDialog.show()

if __name__ == "__main__":
    run()

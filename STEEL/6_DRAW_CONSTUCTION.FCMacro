# -*- coding: utf-8 -*-
import FreeCAD as App
import FreeCADGui as Gui
import Draft, Arch, ArchProfile
from FreeCAD import Vector
from PySide import QtGui, QtCore
import os, sys, re

# --- ustawienia ---
roll_deg = 0.0                 # dodatkowy obrót wokół osi linii [deg]
line_file_name = "_new_single_line.txt"  # nazwa pliku "pamięci" linii
wait_timeout_s = 180           # maks. czas oczekiwania na narysowanie linii

# --- aktywacja A2plus ---
Gui.activateWorkbench("A2plusWorkbench")
a2p_path = os.path.join(App.getUserAppDataDir(), "Mod", "A2plus")
if a2p_path not in sys.path:
    sys.path.append(a2p_path)
import a2p_importpart

# --- weryfikacja dokumentu ---
doc = App.ActiveDocument
if not doc:
    raise RuntimeError("Brak aktywnego dokumentu. Zapisz plik przed uruchomieniem.")
if not doc.FileName:
    raise RuntimeError("Zapisz dokument, aby znać katalog roboczy.")

base_dir   = os.path.dirname(doc.FileName)
single_dir = os.path.join(base_dir, "SINGLE")
os.makedirs(single_dir, exist_ok=True)
line_file_path = os.path.join(base_dir, line_file_name)

def wypal_placement_linii(obj):
    if not hasattr(obj, "Shape") or len(obj.Shape.Vertexes) < 2:
        raise ValueError(f"{obj.Label}: obiekt nie ma geometrii linii (min. 2 wierzchołki).")

    p1_global = obj.Shape.Vertexes[0].Point
    p2_global = obj.Shape.Vertexes[1].Point

    axis_z = (p2_global - p1_global).normalize()
    helper  = App.Vector(1,0,0) if abs(axis_z.dot(App.Vector(0,0,1))) > 0.99 else App.Vector(0,0,1)
    axis_x  = helper.cross(axis_z).normalize()
    axis_y  = axis_z.cross(axis_x).normalize()

    rot_new  = App.Rotation(axis_x, axis_y, axis_z)
    base_new = p1_global
    pl_new   = App.Placement(base_new, rot_new)

    ipl_new        = pl_new.inverse()
    p1_local_new   = ipl_new.multVec(p1_global)
    p2_local_new   = ipl_new.multVec(p2_global)

    try:
        obj.Start = p1_local_new
        obj.End   = p2_local_new
    except Exception:
        try:
            obj.Points = [p1_local_new, p2_local_new]
        except Exception:
            pass

    obj.Placement = pl_new

# --- narzędzia UI ---
def info(msg, title="Informacja"):
    QtGui.QMessageBox.information(None, title, msg)

def warn(msg, title="Błąd"):
    QtGui.QMessageBox.warning(None, title, msg)

# --- utils do pliku linii ---
def write_line_file(p0, p1, path):
    with open(path, "w", encoding="utf-8") as f:
        # format prosty: 2 linie "x y z"
        f.write(f"{p0.x} {p0.y} {p0.z}\n")
        f.write(f"{p1.x} {p1.y} {p1.z}\n")

def read_line_file(path):
    with open(path, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f.readlines() if l.strip()]
    if len(lines) < 2:
        raise ValueError("Plik linii jest niekompletny.")
    def parse_vec(s):
        parts = s.split()
        if len(parts) != 3:
            raise ValueError("Nieprawidłowy format wektora w pliku linii.")
        return Vector(float(parts[0]), float(parts[1]), float(parts[2]))
    return parse_vec(lines[0]), parse_vec(lines[1])

# --- wybór profilu (wg Twojego makra 5_CHANGE_PROFILE) ---
def choose_profile():
    presets = ArchProfile.readPresets()
    if not presets:
        warn("Brak dostępnych profili.")
        return None
    categories = sorted(set([pre[1] for pre in presets]))
    cat, ok = QtGui.QInputDialog.getItem(None, "Wybór kategorii", "Kategoria profilu:", categories, 0, False)
    if not ok:
        return None
    profiles_in_cat = [pre for pre in presets if pre[1] == cat]
    names = sorted([pre[2] for pre in profiles_in_cat])
    prof_name, ok = QtGui.QInputDialog.getItem(None, "Wybór profilu", "Typ profilu:", names, 0, False)
    if not ok:
        return None
    return next((pre for pre in profiles_in_cat if pre[2] == prof_name), None)

# --- czekanie na nowy obiekt typu linia (pewne wykrycie) ---
def wait_for_new_draft_line(set_before, timeout_s):
    # aktywuj narzędzie rysowania
    Gui.activateWorkbench("DraftWorkbench")
    Gui.runCommand('Draft_Line', 0)
    #info("Narysuj linię w widoku (kliknij punkt początkowy i końcowy), a następnie zakończ narzędzie.", "Rysowanie linii")

    loop = QtCore.QEventLoop()
    deadline = QtCore.QTime.currentTime().addSecs(timeout_s)
    found_obj = [None]

    def check_new():
        if QtCore.QTime.currentTime() > deadline:
            loop.quit()
            return
        # znajdź obiekty, których wcześniej nie było
        for obj in doc.Objects:
            if obj.Name not in set_before:
                # szukamy obiektu linii Draft (Part::Part2DObjectPython z 2 wierzchołkami)
                try:
                    shp = getattr(obj, "Shape", None)
                    if shp and hasattr(shp, "Edges") and shp.Edges and len(shp.Vertexes) == 2:
                        found_obj[0] = obj
                        loop.quit()
                        return
                except Exception:
                    pass
        QtCore.QTimer.singleShot(200, check_new)

    QtCore.QTimer.singleShot(200, check_new)
    loop.exec_()
    return found_obj[0]

# --- wybór prefiksu jak w Twoich makrach ---
def get_free_prefix():
    pat = re.compile(r"^(\d{4})")
    used_prefixes = set()
    for o in doc.Objects:
        m = pat.match(o.Label or "")
        if m:
            used_prefixes.add(int(m.group(1)))
    prefix_num = 1000
    while prefix_num in used_prefixes:
        prefix_num += 1
        if prefix_num > 9999:
            raise RuntimeError("Brak wolnych prefiksów.")
    return f"{prefix_num:04d}"

# --- utworzenie SINGLE z domyślnym profilem (potem podmienimy) ---
def create_single_doc(prefix_str, length_val):
    tmp_doc = App.newDocument(f"TmpSingle_{prefix_str}")
    p0 = Vector(0,0,0)
    p1 = Vector(0,0,length_val)
    base_line = Draft.makeLine(p0, p1)
    tmp_doc.recompute()

    profile = ArchProfile.makeProfile()
    profile.Placement.Base = Vector(0,0,length_val/2.0)
    tmp_doc.recompute()

    frame = Arch.makeFrame(base_line, profile)
    tmp_doc.recompute()

    out_file = os.path.join(single_dir, f"{prefix_str}.FCStd")
    tmp_doc.saveAs(out_file)
    App.closeDocument(tmp_doc.Name)
    return out_file

# --- podmiana profilu w SINGLE ---
def change_profile_in_single(file_fc, new_length, prof_data):
    doc_ext = App.openDocument(file_fc)
    frame_ext = doc_ext.getObject("Frame")
    if not frame_ext:
        # heurystyka
        for o in doc_ext.Objects:
            if hasattr(o, "Profile"):
                frame_ext = o
                break
    if not frame_ext:
        App.closeDocument(doc_ext.Name)
        raise RuntimeError("Nie znaleziono obiektu Frame w SINGLE.")

    # usuń stary profil
    try:
        if hasattr(frame_ext, "Profile") and frame_ext.Profile:
            old_prof = frame_ext.Profile
            frame_ext.Profile = None
            doc_ext.recompute()
            try:
                doc_ext.removeObject(old_prof.Name)
            except Exception:
                pass
    except Exception:
        pass

    # utwórz nowy profil z presetów
    new_prof = Arch.makeProfile(prof_data)
    new_prof.Placement.Base = Vector(0,0,new_length/2.0)
    doc_ext.recompute()

    frame_ext.Profile = new_prof
    doc_ext.recompute()
    doc_ext.save()
    App.closeDocument(doc_ext.Name)

# --- wstawienie importu A2plus zamiast linii, zgodnie z Twoją kinematyką ---
def replace_line_with_part(line_obj, file_fc):
    shp = getattr(line_obj, "Shape", None)
    if not shp or not shp.Edges:
        raise RuntimeError("Linia nie posiada krawędzi.")
    edge = shp.Edges[0]
    p0_line = edge.Vertexes[0].Point
    p1_line = edge.Vertexes[1].Point
    dir_norm = (p1_line - p0_line).normalize()

    # usuń linię
    doc.removeObject(line_obj.Name)
    doc.recompute()

    # importuj część z SINGLE
    root = a2p_importpart.importPartFromFile(doc, file_fc)
    part_obj = root
    for c in getattr(root, "OutList", []):
        if getattr(c, "Shape", None) and not c.Shape.isNull():
            part_obj = c
            break

    # oblicz orientację i pozycję (jak w Twoim makrze)
    v0 = part_obj.Shape.Vertexes[0].Point
    v1 = part_obj.Shape.Vertexes[1].Point
    v_part = (v1 - v0).normalize()
    com    = part_obj.Shape.CenterOfMass
    anchor_local = com - v_part.multiply(com.dot(v_part))

    rot_line = App.Rotation(v_part, dir_norm)
    rot_roll = App.Rotation(dir_norm, roll_deg)
    rot_final= rot_roll.multiply(rot_line)

    anchor_global = rot_final.multVec(anchor_local)
    trans         = p0_line - anchor_global

    part_obj.Placement = App.Placement(trans, rot_final)
    doc.recompute()

# --- główna procedura ---
def main():
    # 1) Pobierz p0/p1 z pliku lub narysuj nową linię i zapisz p0/p1 do pliku
    if os.path.isfile(line_file_path):
        try:
            p0, p1 = read_line_file(line_file_path)
        except Exception as e:
            warn(f"Nie udało się odczytać pliku linii:\n{e}")
            return
    else:
        # start rysowania i czekanie na nową linię
        set_before = set(o.Name for o in doc.Objects)
        new_line = wait_for_new_draft_line(set_before, wait_timeout_s)
        if not new_line:
            warn("Nie wykryto nowej linii w wyznaczonym czasie.")
            return
        try:
            p0 = new_line.Shape.Vertexes[0].Point
            p1 = new_line.Shape.Vertexes[1].Point
        except Exception:
            warn("Nie udało się odczytać punktów nowej linii.")
            return
        # zapisz „pamięć”
        try:
            write_line_file(p0, p1, line_file_path)
        except Exception as e:
            warn(f"Nie udało się zapisać pliku linii:\n{e}")
            return

    # 2) Tworzenie SINGLE
    length_val = (p1 - p0).Length
    if length_val <= 0:
        warn("Długość linii jest nieprawidłowa.")
        return

    prefix_str = get_free_prefix()
    file_fc = create_single_doc(prefix_str, length_val)

    # 3) Wybór profilu i podmiana w SINGLE
    prof_data = choose_profile()
    if not prof_data:
        # posprzątaj świeżo utworzony SINGLE, jeżeli chcesz – pomijam kasowanie pliku
        return
    change_profile_in_single(file_fc, length_val, prof_data)

    # 4) Znajdź (lub narysuj) fizyczną linię w modelu i podmień na A2plus
    target_line = None
    # Jeśli „pamięć” powstała z bieżącego rysowania, mamy new_line. Jeśli z pliku – szukamy najbliższej linii o tych samych punktach.
    for obj in doc.Objects:
        try:
            shp = getattr(obj, "Shape", None)
            if not shp or not shp.Edges or len(shp.Vertexes) != 2:
                continue
            q0 = shp.Vertexes[0].Point
            q1 = shp.Vertexes[1].Point
            # porównanie bezwzględne (dokładność modelera jest wystarczająca dla świeżo narysowanej linii)
            if (q0.sub(p0)).Length < 1e-6 and (q1.sub(p1)).Length < 1e-6 or \
               (q0.sub(p1)).Length < 1e-6 and (q1.sub(p0)).Length < 1e-6:
                target_line = obj
                break
        except Exception:
            continue

    # Jeżeli nie znaleziono (np. plik pamięci pochodzi z poprzedniej sesji) – narysuj nową pomocniczą i użyj jej
    if target_line is None:
        target_line = Draft.makeLine(p0, p1)
        doc.recompute()

    replace_line_with_part(target_line, file_fc)

    # --- Wypalenie Placementu linii przed podmianą na część ---
    try:
        wypal_placement_linii(target_line)
    except Exception as e:
        App.Console.PrintMessage(f"{target_line.Label}: pomijam wypalanie – {e}\n")

    # 5) Usuń plik pamięci
    try:
        if os.path.isfile(line_file_path):
            os.remove(line_file_path)
    except Exception:
        pass

    Gui.activateWorkbench("ArchWorkbench")
    #info(f"Gotowe: utworzono {prefix_str}.FCStd i wstawiono element do modelu.", "Gotowe")

if __name__ == "__main__":
    main()

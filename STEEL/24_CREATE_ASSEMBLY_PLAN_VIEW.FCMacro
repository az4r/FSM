# -*- coding: utf-8 -*-
import FreeCAD as App, TechDraw, os, re
from PySide2 import QtWidgets, QtCore
from xml.etree import ElementTree as ET

def log(msg):
    App.Console.PrintMessage(str(msg) + "\n")

# --- Szablony i skala, w stylu 23_CREATE_ASSEMBLY_SECTIONS ---
def list_templates():
    tpl_dir = os.path.join(App.getResourceDir(), "Mod", "TechDraw", "Templates")
    if not os.path.isdir(tpl_dir):
        log(f"!!! Nie znaleziono katalogu Templates: {tpl_dir}")
        return []
    return [f for f in os.listdir(tpl_dir) if f.lower().endswith("svg")]

def select_template_scale_and_zrange():
    files = list_templates()
    if not files:
        return None, None, None, None
    dlg = QtWidgets.QDialog()
    dlg.setWindowTitle("Ustawienia rzutów TechDraw (X-Y)")
    layout = QtWidgets.QVBoxLayout(dlg)

    # skala
    scale_layout = QtWidgets.QHBoxLayout()
    scale_label = QtWidgets.QLabel("Skala:")
    scale_combo = QtWidgets.QComboBox()
    scale_combo.addItems(["1:1", "1:10", "1:50", "1:100", "1:200"])
    scale_layout.addWidget(scale_label)
    scale_layout.addWidget(scale_combo)
    layout.addLayout(scale_layout)

    # szablon
    tpl_label = QtWidgets.QLabel("Szablon:")
    tpl_combo = QtWidgets.QComboBox()
    tpl_combo.addItems(files)
    layout.addWidget(tpl_label)
    layout.addWidget(tpl_combo)

    layout.addSpacing(6)

    # Zmax / Zmin pola (po lewej etykieta, po prawej spinbox)
    z_layout = QtWidgets.QGridLayout()
    zmax_label = QtWidgets.QLabel("Górny zakres rzutu:")
    zmin_label = QtWidgets.QLabel("Dolny zakres rzutu:")
    zmax_spin = QtWidgets.QDoubleSpinBox()
    zmin_spin = QtWidgets.QDoubleSpinBox()
    # konfiguracja zakresów i precyzji jak wcześniej
    for sb in (zmax_spin, zmin_spin):
        sb.setRange(-999999.0, 999999.0)
        sb.setDecimals(2)
        sb.setSingleStep(1.0)
    zmax_spin.setValue(1000.0)
    zmin_spin.setValue(0.0)
    z_layout.addWidget(zmax_label, 0, 0)
    z_layout.addWidget(zmax_spin, 0, 1)
    z_layout.addWidget(zmin_label, 1, 0)
    z_layout.addWidget(zmin_spin, 1, 1)
    layout.addLayout(z_layout)

    # OK (tylko)
    btn_layout = QtWidgets.QHBoxLayout()
    btn_layout.addStretch(1)
    btn_ok = QtWidgets.QPushButton("OK")
    btn_layout.addWidget(btn_ok)
    layout.addLayout(btn_layout)

    btn_ok.clicked.connect(dlg.accept)

    res = dlg.exec_()
    if res != QtWidgets.QDialog.Accepted:
        return None, None, None, None

    tpl_selected = tpl_combo.currentText()
    scale_selected = scale_combo.currentText()
    zmax_val = float(zmax_spin.value())
    zmin_val = float(zmin_spin.value())
    return tpl_selected, scale_selected, zmin_val, zmax_val

# --- Rozmiar strony z template (jak w 23) ---
def _svg_size_from_template(template_path):
    try:
        tree = ET.parse(template_path)
        root = tree.getroot()
        def to_mm(val):
            val = val.strip()
            if val.endswith("mm"): return float(val[:-2])
            if val.endswith("cm"): return float(val[:-2]) * 10.0
            if val.endswith("in"): return float(val[:-2]) * 25.4
            return float(val)
        w = root.get("width")
        h = root.get("height")
        if w and h:
            return to_mm(w), to_mm(h)
        vb = root.get("viewBox")
        if vb:
            parts = vb.strip().split()
            if len(parts) == 4:
                px_to_mm = 0.264583
                try:
                    return float(parts[2]) * px_to_mm, float(parts[3]) * px_to_mm
                except:
                    pass
    except Exception:
        pass
    return None, None

def get_page_size(page, tpl_path):
    try:
        pw = float(getattr(page, "Width"))
        ph = float(getattr(page, "Height"))
        return pw, ph
    except Exception:
        pass
    if tpl_path and os.path.isfile(tpl_path):
        ww, hh = _svg_size_from_template(tpl_path)
        if ww and hh:
            return ww, hh
    return 210.0, 297.0

# --- Filtr obiektów po zakresie Z ---
def get_model_objects(doc):
    return [o for o in doc.Objects if hasattr(o, "Shape") and o.Shape and not o.isDerivedFrom("TechDraw::DrawView")]

def objects_in_z_range(objs, zmin, zmax, eps=1e-6):
    res = []
    for o in objs:
        try:
            bb = o.Shape.BoundBox
            # wybieramy obiekt gdy jego bbox CHOCIAŻBY CZĘŚCIOWO przecina zakres [zmin, zmax]
            if (bb.ZMax >= zmin - eps) and (bb.ZMin <= zmax + eps):
                res.append(o)
        except Exception:
            continue
    return res

# --- helper do bezpiecznej nazwy z zakresu (bez miejsc po przecinku) ---
def sanitize_value(v):
    iv = int(round(v))
    s = str(iv)
    s = s.replace("-", "m")
    return s

# --- Dodatkowe funkcje etykiet z makra 23 --- 
re_num = re.compile(r"^(\d{4})")

def get_single_elements(objs):
    singles = []
    for o in objs:
        label = getattr(o, "Label", "") or ""
        m = re_num.match(label)
        if m:
            singles.append((m.group(1), o))
    return singles

def add_labels_list(page, view, singles):
    # opiera się na logice z 23 — liczy pozycje względem view.X/view.Y i rozmiaru view
    try:
        vx = float(view.X)
    except Exception:
        vx = 0.0
    try:
        vy = float(view.Y)
    except Exception:
        vy = 0.0
    try:
        scale = float(view.Scale)
    except Exception:
        scale = 1.0

    # oblicz bounding box całego widoku z Source
    bb = None
    for src in view.Source:
        try:
            if hasattr(src, "Shape") and src.Shape:
                if bb is None:
                    bb = src.Shape.BoundBox
                else:
                    bb.add(src.Shape.BoundBox)
        except Exception:
            continue

    if bb is not None:
        # dopasuj orientację: dla Top (XY) używamy X->X, Y->Y
        # vW, vH w mm przy skali (przybliżenie)
        vW = (bb.XMax - bb.XMin) * scale
        vH = (bb.YMax - bb.YMin) * scale
    else:
        vW = vH = 0.0

    ox = vx - vW / 2.0
    oy = vy - vH / 2.0

    for (num, obj) in singles:
        try:
            anno = App.ActiveDocument.addObject('TechDraw::DrawRichAnno', f"Anno_{num}_{page.Name}")
            page.addView(anno)
            # prosta treść HTML — numer
            anno.AnnoText = """<!DOCTYPE HTML><html><body style="font-family:'Arial'; font-size:10pt; font-weight:bold;"><p>""" + str(num) + """</p></body></html>"""
            anno.ShowFrame = True
            cx = float(obj.Shape.BoundBox.Center.x)
            cy = float(obj.Shape.BoundBox.Center.y)
            cz = float(obj.Shape.BoundBox.Center.z)
            # dla top view (Direction (0,0,1)) używamy X= cx, Y=cy
            lx = cx * scale + ox
            ly = cy * scale + oy
            anno.X = lx
            anno.Y = ly
        except Exception:
            continue

# --- Główna funkcja: rzut X-Y z zakresem Z ---
def create_xy_top_view_with_z_range():
    doc = App.ActiveDocument
    if not doc:
        log("Brak aktywnego dokumentu.")
        return

    # 1) Wybór template + skala + zmin/zmax w jednym dialogu
    tpl_name, scale_str, zmin, zmax = select_template_scale_and_zrange()
    if not tpl_name or not scale_str:
        log("Nie wybrano szablonu, skali lub zakresu Z. Anuluję.")
        return
    if zmin is None or zmax is None:
        log("Brak poprawnego zakresu Z. Anuluję.")
        return
    if zmin > zmax:
        zmin, zmax = zmax, zmin

    num, den = scale_str.split(":")
    scale_val = float(num) / float(den)
    tpl_path = os.path.join(App.getResourceDir(), "Mod", "TechDraw", "Templates", tpl_name)

    # 2) Zbierz obiekty w zakresie
    model_objs_all = get_model_objects(doc)
    model_objs = objects_in_z_range(model_objs_all, zmin, zmax)

    if not model_objs:
        log(f"Brak obiektów w zakresie Z=[{zmin}..{zmax}].")
        return

    # przygotuj bezpieczny dopisek do nazwy (bez miejsc po przecinku)
    zmin_s = sanitize_value(zmin)
    zmax_s = sanitize_value(zmax)
    page_name = f"TopView_XY_{zmin_s}_{zmax_s}"

    # 3) Utwórz stronę i widok Top (XY)
    page = doc.addObject('TechDraw::DrawPage', page_name)
    tpl_obj = doc.addObject('TechDraw::DrawSVGTemplate', 'Template_TopView_XY')
    tpl_obj.Template = tpl_path
    page.Template = tpl_obj

    view = doc.addObject('TechDraw::DrawViewPart', 'View_Top_XY')
    view.Source = model_objs
    view.Direction = (0, 0, 1)      # z góry: oś +Z
    view.ScaleType = "Custom"
    view.Scale = scale_val
    page.addView(view)

    # dodaj etykiety (numery pojedynczych elementów) — minimalne dodanie z 23
    try:
        singles_visible = get_single_elements(model_objs)
        if singles_visible:
            add_labels_list(page, view, singles_visible)
    except Exception:
        pass

    # 4) Centrowanie widoku na stronie
    doc.recompute()
    page_w, page_h = get_page_size(page, tpl_path)
    try:
        vw = float(view.Width)
        vh = float(view.Height)
        view.X = (page_w - vw) / 2.0
        view.Y = (page_h - vh) / 2.0
    except Exception:
        pass

    doc.recompute()
    log(f"=== Utworzono rzut X-Y dla obiektów w zakresie Z=[{zmin}..{zmax}], skala={scale_str}, szablon={tpl_name} ===")

if __name__ == "__main__":
    create_xy_top_view_with_z_range()

# -*- coding: utf-8 -*-
import FreeCAD as App, TechDraw, os, re
from PySide2 import QtWidgets
from xml.etree import ElementTree as ET

def log(msg):
    App.Console.PrintMessage(str(msg) + "\n")

def list_templates():
    tpl_dir = os.path.join(App.getResourceDir(), "Mod", "TechDraw", "Templates")
    if not os.path.isdir(tpl_dir):
        log(f"!!! Nie znaleziono katalogu Templates: {tpl_dir}")
        return []
    return [f for f in os.listdir(tpl_dir) if f.lower().endswith("svg")]

def select_template_and_scale():
    files = list_templates()
    if not files:
        return None, None
    dlg = QtWidgets.QDialog()
    dlg.setWindowTitle("Ustawienia przekrojów TechDraw")
    layout = QtWidgets.QVBoxLayout(dlg)
    scale_layout = QtWidgets.QHBoxLayout()
    scale_label = QtWidgets.QLabel("Skala:")
    scale_combo = QtWidgets.QComboBox()
    scale_combo.addItems(["1:1", "1:10", "1:50", "1:100", "1:200"])
    scale_layout.addWidget(scale_label)
    scale_layout.addWidget(scale_combo)
    layout.addLayout(scale_layout)
    tpl_label = QtWidgets.QLabel("Szablon:")
    tpl_combo = QtWidgets.QComboBox()
    tpl_combo.addItems(files)
    layout.addWidget(tpl_label)
    layout.addWidget(tpl_combo)
    btn_ok = QtWidgets.QPushButton("OK")
    layout.addWidget(btn_ok)
    btn_ok.clicked.connect(dlg.accept)
    dlg.exec_()
    return tpl_combo.currentText(), scale_combo.currentText()

re_num = re.compile(r"^(\d{4})")

def get_model_objects(doc):
    return [o for o in doc.Objects if hasattr(o,"Shape") and o.Shape and not o.isDerivedFrom("TechDraw::DrawView")]

def get_single_elements(objs):
    singles = []
    for o in objs:
        label = getattr(o,"Label","") or ""
        m = re_num.match(label)
        if m: singles.append((m.group(1),o))
    return singles

# --- pomocnicza: pobiera rozmiar arkusza z pliku szablonu SVG ---
def _svg_size_from_template(template_path):
    try:
        tree = ET.parse(template_path)
        root = tree.getroot()
        def to_mm(val):
            val = val.strip()
            if val.endswith("mm"): return float(val[:-2])
            if val.endswith("cm"): return float(val[:-2]) * 10.0
            if val.endswith("in"): return float(val[:-2]) * 25.4
            return float(val)
        w = root.get("width")
        h = root.get("height")
        if w and h:
            return to_mm(w), to_mm(h)
        vb = root.get("viewBox")
        if vb:
            parts = vb.strip().split()
            if len(parts) == 4:
                px_to_mm = 0.264583
                try:
                    return float(parts[2]) * px_to_mm, float(parts[3]) * px_to_mm
                except:
                    pass
    except Exception:
        pass
    return None, None

def get_page_size(page, tpl_path):
    # 1) spróbuj page.Width/page.Height (nie zawsze dostępne)
    try:
        pw = float(getattr(page, "Width"))
        ph = float(getattr(page, "Height"))
        return pw, ph
    except Exception:
        pass
    # 2) spróbuj plik SVG szablonu
    if tpl_path and os.path.isfile(tpl_path):
        ww, hh = _svg_size_from_template(tpl_path)
        if ww and hh:
            return ww, hh
    # 3) fallback A4
    return 210.0, 297.0

# add_labels_list: wersja z v2 — etykiety liczone względem view.X/view.Y i przesunięcia grupy
def add_labels_list(page, view, singles):
    vx = float(view.X)
    vy = float(view.Y)
    scale = float(view.Scale)

    # --- oblicz rozmiar rzutni na podstawie wszystkich obiektów ---
    bb = None
    for src in view.Source:
        if hasattr(src, "Shape"):
            if bb is None:
                bb = src.Shape.BoundBox
            else:
                bb.add(src.Shape.BoundBox)

    if bb is not None:
        if tuple(view.Direction) == (1,0,0):      # widok wzdłuż osi X → (Y,Z)
            vW = (bb.YMax - bb.YMin) * scale
            vH = (bb.ZMax - bb.ZMin) * scale
        elif tuple(view.Direction) == (0,-1,0):   # widok wzdłuż osi Y → (X,Z)
            vW = (bb.XMax - bb.XMin) * scale
            vH = (bb.ZMax - bb.ZMin) * scale
        else:                                     # fallback → XY
            vW = (bb.XMax - bb.XMin) * scale
            vH = (bb.YMax - bb.YMin) * scale
    else:
        vW = vH = 0.0

    # --- przesunięcie całej grupy o połowę szerokości i wysokości ---
    ox = vx - vW/2.0
    oy = vy - vH/2.0

    # --- teraz etykiety ---
    for (num, obj) in singles:
        anno = App.ActiveDocument.addObject('TechDraw::DrawRichAnno', f"Anno_{num}_{page.Name}")
        page.addView(anno)
        anno.AnnoText = f"""<!DOCTYPE HTML><html><body style="font-family:'Arial'; font-size:10pt; font-weight:bold;"><p>{num}</p></body></html>"""
        anno.ShowFrame = True

        cx = float(obj.Shape.BoundBox.Center.x)
        cy = float(obj.Shape.BoundBox.Center.y)
        cz = float(obj.Shape.BoundBox.Center.z)

        if tuple(view.Direction) == (1,0,0):
            lx = cy * scale + ox
            ly = cz * scale + oy
        elif tuple(view.Direction) == (0,-1,0):
            lx = cx * scale + ox
            ly = cz * scale + oy
        else:
            lx = cx * scale + ox
            ly = cy * scale + oy

        anno.X = lx
        anno.Y = ly

def objects_crossing_plane_X(objs, x_pos, eps=1e-6):
    res=[]
    for o in objs:
        bb=o.Shape.BoundBox
        if bb.XMin-eps <= x_pos <= bb.XMax+eps:
            res.append(o)
    return res

def objects_crossing_plane_Y(objs, y_pos, eps=1e-6):
    res=[]
    for o in objs:
        bb=o.Shape.BoundBox
        if bb.YMin-eps <= y_pos <= bb.YMax+eps:
            res.append(o)
    return res

def objects_in_x_range_by_center(objs,xmin,xmax,eps=1e-6):
    res=[]
    for o in objs:
        try:
            cx=float(o.Shape.BoundBox.Center.x)
            if xmin-eps<=cx<=xmax+eps: res.append(o)
        except: continue
    return res

def objects_in_y_range_by_center(objs,ymin,ymax,eps=1e-6):
    res=[]
    for o in objs:
        try:
            cy=float(o.Shape.BoundBox.Center.y)
            if ymin-eps<=cy<=ymax+eps: res.append(o)
        except: continue
    return res

# --- główna logika ---
doc=App.ActiveDocument
if not doc:
    log("Brak aktywnego dokumentu.")
else:
    grid=doc.getObject("Grid")
    if not grid:
        log("Nie znaleziono obiektu Grid.")
    else:
        tpl,scale_str=select_template_and_scale()
        if not tpl or not scale_str:
            log("Nie wybrano szablonu lub skali. Anuluję.")
        else:
            num,den=scale_str.split(":")
            scale_val=float(num)/float(den)
            cols=int(grid.Columns); rows=int(grid.Rows)
            col_sizes=[float(x) for x in list(grid.ColumnSize)]
            row_sizes=[float(y) for y in list(grid.RowSize)]
            log(f"Grid: {cols} kolumn, {rows} wierszy")
            tpl_path=os.path.join(App.getResourceDir(),"Mod","TechDraw","Templates",tpl)
            model_objs_all=get_model_objects(doc)

            # --- X ---
            x_pos=0.0
            for i in range(cols+1):
                try:
                    page=doc.addObject('TechDraw::DrawPage',f"Section_X_{i}")
                    tpl_obj=doc.addObject('TechDraw::DrawSVGTemplate',f"Template_X_{i}")
                    tpl_obj.Template=tpl_path; page.Template=tpl_obj

                    half_next=0.5*abs(col_sizes[i]) if i<cols else 0.0
                    xmin=x_pos; xmax=x_pos+half_next

                    # używamy logiki z v2: obiekty przecinające płaszczyznę + te w zakresie
                    objs_plane = objects_crossing_plane_X(model_objs_all, x_pos)
                    objs_range = objects_in_x_range_by_center(model_objs_all, xmin, xmax)
                    model_objs = list(set(objs_plane + objs_range))

                    # minimalna poprawka: upewnij się, że Grid jest w źródle widoku
                    if grid is not None and grid not in model_objs:
                        model_objs.append(grid)

                    log(f"X_{i}: plane={x_pos}, range=[{xmin},{xmax}], found {len(model_objs)} objects")

                    if model_objs:
                        view=doc.addObject('TechDraw::DrawViewPart',f"View_X_{i}")
                        view.Source=model_objs; view.Direction=(1,0,0)
                        view.ScaleType="Custom"; view.Scale=scale_val
                        page.addView(view)

                        # centrowanie widoku: pobierz rozmiar strony i ustaw X/Y jeśli view ma Width/Height
                        doc.recompute()
                        page_w, page_h = get_page_size(page, tpl_path)
                        try:
                            vw = float(view.Width)
                            vh = float(view.Height)
                            view.X = (page_w - vw) / 2.0
                            view.Y = (page_h - vh) / 2.0
                        except Exception:
                            # fallback: zostaw dotychczasowe/domyslne wartości
                            pass
                        doc.recompute()

                        singles_visible=get_single_elements(model_objs)
                        add_labels_list(page,view,singles_visible)

                    if i<len(col_sizes): x_pos+=abs(col_sizes[i])
                except Exception as e: log(f"X_{i}: błąd {e}")

            # --- Y ---
            y_pos=0.0
            for j in range(rows+1):
                try:
                    page=doc.addObject('TechDraw::DrawPage',f"Section_Y_{j}")
                    tpl_obj=doc.addObject('TechDraw::DrawSVGTemplate',f"Template_Y_{j}")
                    tpl_obj.Template=tpl_path; page.Template=tpl_obj

                    half_next=0.5*abs(row_sizes[j]) if j<rows else 0.0
                    ymin_model=y_pos; ymax_model=y_pos+half_next

                    objs_plane = objects_crossing_plane_Y(model_objs_all, y_pos)
                    objs_range = objects_in_y_range_by_center(model_objs_all, ymin_model, ymax_model)
                    model_objs = list(set(objs_plane + objs_range))

                    if grid is not None and grid not in model_objs:
                        model_objs.append(grid)

                    log(f"Y_{j}: plane={y_pos}, range=[{ymin_model},{ymax_model}], found {len(model_objs)} objects")

                    if model_objs:
                        view=doc.addObject('TechDraw::DrawViewPart',f"View_Y_{j}")
                        view.Source=model_objs; view.Direction=(0,-1,0)
                        view.ScaleType="Custom"; view.Scale=scale_val
                        page.addView(view)

                        # centrowanie widoku: pobierz rozmiar strony i ustaw X/Y jeśli view ma Width/Height
                        doc.recompute()
                        page_w, page_h = get_page_size(page, tpl_path)
                        try:
                            vw = float(view.Width)
                            vh = float(view.Height)
                            view.X = (page_w - vw) / 2.0
                            view.Y = (page_h - vh) / 2.0
                        except Exception:
                            pass
                        doc.recompute()

                        singles_visible=get_single_elements(model_objs)
                        add_labels_list(page,view,singles_visible)

                    if j<len(row_sizes): y_pos+=abs(row_sizes[j])
                except Exception as e: log(f"Y_{j}: błąd {e}")

            doc.recompute()
            log("=== Utworzono przekroje i listy etykiet dla wszystkich osi Grid ===")
